<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Patchwork with Coexisting Cellular Automata - Phileas Dazeley-Gaist</title><meta name="description" content="Note: This post was originally a short technical article I shared on&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><script type="text/javascript" async src="https://www.googletagmanager.com/gtag/js?id=G-K13VH578CQ"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];
				  function gtag(){dataLayer.push(arguments);}
				  gtag('js', new Date());
				  gtag('config', 'G-K13VH578CQ' );</script><link rel="canonical" href="https://phileasdg.github.io/patchwork-with-coexisting-cellular-automata/"><link rel="alternate" type="application/atom+xml" href="https://phileasdg.github.io/feed.xml" title="Phileas Dazeley-Gaist - RSS"><link rel="alternate" type="application/json" href="https://phileasdg.github.io/feed.json" title="Phileas Dazeley-Gaist - JSON"><meta property="og:title" content="Patchwork with Coexisting Cellular Automata"><meta property="og:image" content="https://phileasdg.github.io/media/posts/53/banner-2.png"><meta property="og:image:width" content="3083"><meta property="og:image:height" content="1539"><meta property="og:site_name" content="Phileas Dazeley-Gaist"><meta property="og:description" content="Note: This post was originally a short technical article I shared on&hellip;"><meta property="og:url" content="https://phileasdg.github.io/patchwork-with-coexisting-cellular-automata/"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@phileasdg"><meta name="twitter:title" content="Patchwork with Coexisting Cellular Automata"><meta name="twitter:description" content="Note: This post was originally a short technical article I shared on&hellip;"><meta name="twitter:image" content="https://phileasdg.github.io/media/posts/53/banner-2.png"><link rel="stylesheet" href="https://phileasdg.github.io/assets/css/style.css?v=ff30ce3ac4c3be676e9c9a0dc5db8575"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://phileasdg.github.io/patchwork-with-coexisting-cellular-automata/"},"headline":"Patchwork with Coexisting Cellular Automata","datePublished":"2026-01-17T10:53-05:00","dateModified":"2026-01-17T12:42-05:00","image":{"@type":"ImageObject","url":"https://phileasdg.github.io/media/posts/53/banner-2.png","height":1539,"width":3083},"description":"Note: This post was originally a short technical article I shared on&hellip;","author":{"@type":"Person","name":"Phileas Dazeley-Gaist","url":"https://phileasdg.github.io/authors/phileas-dazeley-gaist/"},"publisher":{"@type":"Organization","name":"Phileas Dazeley-Gaist"}}</script><a hidden rel="me" href="https://mathstodon.xyz/@phileasdg">Mastodon</a></head><body><header class="header" id="js-header"><a href="https://phileasdg.github.io/" class="logo">Phileas Dazeley-Gaist</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://phileasdg.github.io/" target="_self">Home</a></li><li><a href="https://phileasdg.github.io/guest-lectures-and-public-speaking-events/" target="_self">Public Speaking</a></li><li><a href="http://phileasdg.github.io/playgrounds" target="_self">Playgrounds</a></li><li><a href="https://phileasdg.github.io/publications/" target="_self">Publications</a></li><li><a href="https://phileasdg.github.io/a-few-words-about-me/" target="_self">About</a></li><li><a href="https://phileasdg.github.io/resume-cv/" target="_self">Resume / CV</a></li><li><a href="https://phileasdg.github.io/inquiries/" target="_self">Inquiries</a></li></ul></nav></header><main><div class="wrapper"><article class="post"><header class="post__header"><a href="https://phileasdg.github.io/tags/cellular-automata/" class="post__maintag">Cellular Automata</a><h1 class="post__title">Patchwork with Coexisting Cellular Automata</h1><div class="post__meta"><time datetime="2026-01-17T10:53">January 17, 2026</time></div></header><figure class="post__featured-image"><img src="https://phileasdg.github.io/media/posts/53/banner-2.png" srcset="https://phileasdg.github.io/media/posts/53/responsive/banner-2-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/banner-2-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/banner-2-md.png 768w, https://phileasdg.github.io/media/posts/53/responsive/banner-2-lg.png 1200w" sizes="(min-width: 56.25em) 100vw, (min-width: 37.5em) 50vw, 100vw" loading="eager" height="1539" width="3083" alt=""></figure><div class="post__inner"><div class="post__entry"><p class="msg msg--info"><strong>Note: </strong>This post was originally a short technical article I shared on the Wolfram Community forum. For an interactive experience with live demonstrations or to download this text alongside the source code, please visit the original post <a href="https://community.wolfram.com/groups/-/m/t/3608683?p_p_auth=C3EsWlzT">here</a>. </p><h2>Introduction</h2><p>At the 2025 Wolfram Summer School, while advising on a project about collaborative decision-making using cellular automata (CAs), I spent some time thinking up different possible setups to get CA rules to interact with each other and perform "negotiations". We considered several setups, including using CA state cells to represent a distribution of opinions in a society, and tried various schemes in an attempt to evolve rules that would reliably yield "consensus" states.</p><p>One approach that I did not have time to dive into but that showed promise was to represent agents as rules confined to specific, strictly different regions in space, but able to interact with each other where their boundaries touch or are close to one another. Setups like this will be the subject of this short essay.</p><p>Here's a teaser of what we're working toward: Programs that operate on a cellular automaton state arrays by applying a list of cellular automata rules to a list of non-overlapping regions of the state, such that each defined region is subject to its own dynamics, determined both by the region's assigned rule and the dynamics near the region boundary.</p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/cellsetup.gif" alt="" width="559" height="406"></figure><h2>Cellular automata with custom boundary conditions</h2><p>We'll work our way up to CAs operating in parallel on non-overlapping regions of space. But first, it'll be helpful to review some of the basics. </p><h3>One-dimensional CAs</h3><h4>Natively supported CA boundary conditions</h4><p>In Wolfram Language, cellular automata default to having periodic boundary conditions.</p><p><em>Elementary cellular automaton trajectory with periodic boundary conditions:<br></em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-11.31.52.png" alt="" width="225" height="226" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.31.52-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.31.52-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.31.52-md.png 768w"></figure><p>Notice the ripple cascade that wraps around horizontal space as it leaves to the right and simultaneously enters to the left.</p><p>The natively supported alternative to periodic boundary conditions in the CellularAutomaton function is to have CAs running on an infinite canvas.</p><p><em>Elementary cellular automaton trajectory on an infinite canvas:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-11.33.15.png" alt="" width="225" height="226" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.33.15-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.33.15-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.33.15-md.png 768w"></figure><p>Here, the width of the state array is not fixed. In this case, the ripple cascade simply propagates outwards forever, uninterrupted.</p><p>The system we are envisioning requires that we implement custom boundary conditions, which there is no built in support for at the moment as far as I can tell. So how can we get there?</p><h4>Confining CAs to regions in space</h4><p>To confine a rule to a spatial region within a CA state, the simplest general approach I can think of is to apply the rule to the full state, but discard all changes to the state outside the rule's assigned region using a region mask. For example:</p><p><em>Trajectory of a rule 30 CA confined to a small region of the simulation space:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-11.34.19.png" alt="" width="225" height="227" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.34.19-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.34.19-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.34.19-md.png 768w"></figure><p>In the plot above, the green region represents the spatial domain of the automaton rule. Changes made to the state by the rule will only take effect inside the green region. </p><p>Proceeding this way means that although the green automaton is unable to make changes to cells outside the green region, green region cells near the border still "sense", and are affected by the state of cells on the other side of the border. If a green-region cell's neighbourhood contains cells from different regions, those cell states are used to determine the new cell state just as they would usually be. What this achieves is making the automaton region boundaries porous by default. The dynamics in the green region are affected by the local dynamics outside of the green region.</p><p>In the present example, the background is held constant and uniform. But there's not reason it has to be. If the background were heterogenous and dynamic, our setup would work just as well, though the dynamics in the green region would  be different as the state evolution would be subject to different kinds of interference from local background activity. We'll return to this point later.</p><p>Another important clarification is that while in the simulations above, the chosen rule is confined to a region with a constant spatial boundary, the simulation itself is still operating in a periodic space. This distinction is essential because it means that cells on the periphery of the state array are still considered adjacent to cells on their opposite sides. In the example above, the left and right sides of the state array are still glued together. If a rule's assigned region were to span from one end of the state to the other, it would be possible for event cascades to wrap around.</p><p><em>Trajectory of a rule 30 CA confined to a region that wraps around the periodic boundaries of the simulation space:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-11.35.45.png" alt="" width="225" height="227" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.35.45-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.35.45-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.35.45-md.png 768w"></figure><h4>Removing spatial periodicity</h4><p>To also get rid of the periodic boundary conditions of the space itself, my suggestion is a bit hacky but functional: Pad any starting CA state with enough zeros in all directions to prevent periodic interaction at the edges of the state array, compute the next step, and trim the resulting array so as to recover the original dimensions. Repeat as needed. Padding by the automaton neighbourhood  range is easy and guaranteed to be enough (the minimum required padding depends on the neighbourhood used by automata in the simulation, so I won't discuss it here). </p><p><em>Cellular automaton trajectory with a rule 30 CA confined to a visually identical region as in the previous example, but that does not wrap around the periodic boundaries of the simulation space:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-11.36.30.png" alt="" width="225" height="226" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.36.30-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.36.30-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.36.30-md.png 768w"></figure><p>Now, on the left and right sides of the state array, the background is effectively taken to be all zeros, so the rightmost cascade can never wrap around to the left, and the simulation space is fixed. In this specific case, the change also causes both green regions to start with the same initial conditions. As the neighbours to the left of the leftmost cell of each green region at t=0 are now considered to be zero, the initial conditions cause two cascades instead of one.</p><p>We chose to have uniform and constant zero boundary conditions for the entire simulation space, but as before, we could have done otherwise. Here is an example in which these boundary conditions are made random and dynamic.</p><p><em>Rule 30 CA trajectory confined to a region subject to random and dynamic boundary conditions:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-11.37.05.png" alt="" width="225" height="226" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.37.05-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.37.05-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.37.05-md.png 768w"></figure><p>Here, the states of the cells that make up the boundary change at random, affecting the dynamics of the green automaton, although the boundary itself does not move around. The boundary is fixed in space, but not fixed in state.</p><h3>Two-dimensional CAs</h3><p>Now that we've established some techniques for confining 1D cellular automata to specific regions, the natural next step is to apply these ideas to 2D CAs. Good news! The techniques we just discussed for 1D CAs work just as well in 2D, and even in higher dimensions.</p><p>Here's a setup in two dimensions that confines a totalistic 9-neighbour CA to a square region of the simulation space.</p><p><em>Dynamics of a totalistic 9-neighbor CA confined to a square region of the simulation space:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/squaresetup.gif" alt="" width="300" height="300"></figure><p>Just as before:</p><ul><li>The green region represents the spatial domain of the automaton rule. </li><li>The boundary is porous, so nearby activity outside the green region can affect green region dynamics.</li><li>The boundary conditions for the whole simulation space are still periodic by default, but can be fixed or controlled using the masking techniques I described for 1D CAs.</li></ul><p>Since the green region is determined by a binary mask array, we can easily try almost any setup you can think of painting out on a canvas. In the next few examples, I use a region with an inner isolated part with constant zero boundary conditions, and an outer part that connects every edge of the simulation window. The inner part will be undisturbed by any changes to the global, simulation space boundary conditions, so its dynamics can be thought of as a control in our experiments.</p><p>Here's a setup where the green region allows the dynamics to wrap around along each axis.</p><p><em>Totalistic 9-neighbor CA dynamics constrained to a region with an isolated central component subject to fixed zero boundary conditions, and a surrounding component subject to the periodic boundary conditions of the simulation space:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/crosssetupperiodic.gif" alt="" width="300" height="300"></figure><p>You can think of the space as wrapping around a torus like this:</p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-11.45.55.png" alt="" width="225" height="205" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.45.55-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.45.55-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.45.55-md.png 768w"></figure><p>Here's a setup with the same green region specification, but with constant zero boundary conditions applied to the simulation space.</p><p><em>Totalistic 9-neighbor CA dynamics constrained to a region with an isolated central component subject to fixed zero boundary conditions, and a surrounding component also subject to fixed boundary conditions:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/crosssetupconstantzero-2.gif" alt="" width="300" height="300"></figure><p>Setting constant zero boundary conditions turns the boundaries of the simulation window into smooth, solid, impenetrable walls, preventing the dynamics of the green CA from wrapping around.</p><p>Finally, here's an example in which these boundary conditions are made random and dynamic.</p><p><em>Totalistic 9-neighbor CA dynamics constrained to a region with an isolated central component subject to fixed zero boundary conditions, and a surrounding component subject to random dynamic boundary conditions:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/crosssetupdynamicrandom.gif" alt="" width="301" height="301"></figure><p>In this last case, the dynamics in the outer part appear quite random.</p><h3>Three dimensions and above</h3><p>Just to show that it's possible, here's a complicated 3D example using a state generated by another 3D CA as the automaton region mask.</p><p><em>Dynamics of a 3D CA confined to a complex 3D region:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/3Dsetup.gif" alt="" width="300" height="326"></figure><p>And here's a simulation of the process in six dimensions, just for fun, although there's no longer a simple way to visualize its output, so all I'll show you is this preview of the final state array: </p><figure class="post__image"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-11.52.45.png" alt="" width="1224" height="126" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.52.45-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.52.45-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.52.45-md.png 768w"></figure><h3>Bonus: miscellaneous interesting examples</h3><h4>Mazes</h4><p><em>Generate a maze to use as a mask:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-11.53.16.png" alt="" width="225" height="229" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.53.16-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.53.16-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.53.16-md.png 768w"></figure><p><em>Compute the trajectory of a 9-neighbour 2D totalistic CA confined by the mask:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/mazesetup.gif" alt="" width="300" height="300"></figure><h4>Other complex shapes</h4><p><em>Define an organic shape shape to use as a mask:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-11.55.53.png" alt="" width="225" height="234" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.55.53-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.55.53-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-11.55.53-md.png 768w"></figure><p><em>Compute the trajectory of a 9-neighbour 2D totalistic CA confined by the mask:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/flowersetup.gif" alt="" width="300" height="308"></figure><h3>Review</h3><p>In this section, we explored techniques for confining cellular automata to specific spatial regions within a larger CA system. In summary:</p><ul><li>The CellularAutomaton function supports two default boundary conditions, periodic and infinite.</li><li>To confine a CA rule to a specific spatial region, we can apply the rule to the full state, but discard all changes outside the rule's assigned region using a region mask. </li><li>To remove the periodic boundary conditions of the space itself, we can pad the initial state with enough zeros in all directions to prevent periodic interaction at the edges, compute the next step, and trim the resulting array back to the original dimensions. This effectively simulates constant zero boundary conditions. </li><li>By controlling the padding values we can set different kinds of global boundary conditions. Padding with ones will simulate uniform and constant one boundary conditions. Padding with zeros and ones in different places will result in non-uniform boundary conditions. In general, boundary conditions must be defined with valid cell states: zero or one for two-state CAs, and zero through <em>k-1</em> for <em>k</em> state CAs.</li><li>We can also make the boundary conditions of the simulation space dynamic and heterogeneous, for example, by defining a global boundary mask that frames the simulation window, and setting cells within the boundary it defines to random states at every step of the simulation. Any CA whose spatial domain is close enough to the global boundary mask will see its dynamics affected by the random global boundary conditions.</li><li>These techniques can be applied to 1D and 2D CAs, but also to CAs in higher dimensional spaces. </li></ul><h2>Coexisting Cellular Automata: <br>Running CAs in parallel in separate regions of space</h2><h3>How does it work?</h3><p>We can use the tools developed above to perform simulations in which several CA rules operate in parallel on non-overlapping regions of the simulation space. I'll refer to simulations like these as Coexisting CAs, and since I'm going to want to experiment with Coexisting CAs a lot, I'll define a <em>CoexistingCellularAutomata</em> function to automate the process of setting up and running these simulations. The full function definition can be found in the <em>Code Initialisation</em> section at the end of the <a href="https://community.wolfram.com/groups/-/m/t/3608683?p_p_auth=A7Xz7iqu">Wolfram Community version of this article</a>.</p><p>The core steps of the process are: </p><ol><li>Define a list of CA rules and an initial state for the entire simulation space.</li><li>Create an array that specifies the spatial domain for each CA rule, where each cell in the array corresponds to the index of the rule that should be applied in that region.</li><li>Generate binary masks from the spatial domains array to isolate the regions where each rule should be applied.</li><li>Define boundary conditions for the overall simulation space, which can be constant or dynamic.</li><li>Apply the CA rules to their respective domains, clip the results to the domain masks, sum the resulting state arrays, and apply the global boundary conditions.</li></ol><h3>Computing a single step of a Coexisting CA simulation</h3><p>This next code snippet demonstrates the process I settled on in my final implementation to compute a single Coexisting CA simulation step. I've included comments to describe the process alongside the code, and calls to Echo and EchoFunction to show key variables generated or used in the throughout its execution.</p><figure class="post__image align-left"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.02.24.png" alt="" width="600" height="605" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.02.24-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.02.24-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.02.24-md.png 768w"></figure><figure class="post__image"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.03.30.png" alt="" width="600" height="496" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.03.30-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.03.30-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.03.30-md.png 768w"></figure><h3>Performing a full Coexisting CA simulation</h3><p>The CoexistingCellularAutomata function makes simulations of interacting CAs quite easy to set up and perform. Let me show you.</p><p>I'll start by defining my simulation parameters. For this example, I'll pick 10 rules at random. Each rule domain will be assigned its own colour.</p><figure class="post__image"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.04.25.png" alt="" width="272" height="98" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.04.25-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.04.25-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.04.25-md.png 768w"></figure><p><em>Pick some 2 colour range 9-neighbour totalistic CA rules at random:</em></p><figure class="post__image"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.05.09.png" alt="" width="609" height="117" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.05.09-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.05.09-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.05.09-md.png 768w"></figure><p>I'll set constant zero initial conditions across the initial state.</p><p><em>Define an initial array representing the state at t=0:</em></p><figure class="post__image"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.05.51.png" alt="" width="396" height="101" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.05.51-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.05.51-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.05.51-md.png 768w"></figure><p>The spatial domains of each CA rule in the simulation must be specified using a single array of integer values corresponding to indices of the supplied rules in the rule list, or zero, meaning "no rules apply here". </p><p>We can arbitrarily partition the simulation space and assign whichever parts we choose to whichever rules we like. Here, I've used a helper function called <em>generateVoronoiCASpatialDomains</em> (defined in the <em>Code Initialisation</em> section of the <a href="https://community.wolfram.com/groups/-/m/t/3608683?p_p_auth=A7Xz7iqu">Wolfram Community version of this essay</a>) to generate the rule domain definitions array.</p><p><em>Define the spatial domains of each rule in the simulation space:</em></p><figure class="post__image"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.07.05.png" alt="" width="529" height="52" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.07.05-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.07.05-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.07.05-md.png 768w"></figure><p><em>Preview the domain masks:</em></p><figure class="post__image"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.07.31.png" alt="" width="575" height="168" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.07.31-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.07.31-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.07.31-md.png 768w"></figure><p>To perform a simulation, simply supply the list of rules, domain mask, initial state, and number of steps to the CoexistingCellularAutomata function.</p><p><em>Perform a simulation using CoexistingCellularAutomata:</em></p><figure class="post__image"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.08.45.png" alt="" width="405" height="205" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.08.45-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.08.45-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.08.45-md.png 768w"></figure><figure class="post__image"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.09.03.png" alt="" width="680" height="372" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.09.03-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.09.03-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.09.03-md.png 768w"></figure><p>The result is a list of arrays representing the sequence of Coexisting CA states, each of which we can plot to make the frames of an animation of the full simulation trajectory.</p><p><em>Animate the resulting simulation of interacting CAs, using the masks to colour the frames:</em></p><figure class="post__image"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.09.50.png" alt="" width="586" height="172" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.09.50-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.09.50-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.09.50-md.png 768w"></figure><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/voronoisetup-2.gif" alt="" width="650" height="473"></figure><h3>Using images as Coexisting CA domain Masks</h3><p>The CoexistingCellularAutomata function works with arbitrary valid rule domain definitions. Any array of positive or zero integer values is a valid rule domain mask. This means we can use posterized images as rule domain specifications.</p><p>For this next example, I posterized a webcam selfie so as to only have pixel values of 0,1, or 2 and used the resulting image as the domain mask specification in CoexistingCellularAutomata. In the simulation, these values respectively correspond to neutral territory, the domain of the first rule, and the domain of the second rule. I picked two totalistic 9-neighbour 2D CA rules to use at random:</p><p><em>Define a mask to use in the simulation:</em></p><figure class="post__image"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.15.08.png" alt="" width="651" height="180" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.15.08-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.15.08-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.15.08-md.png 768w"></figure><figure class="post__image"><em><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.15.31.png" alt="" width="302" height="192" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.15.31-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.15.31-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.15.31-md.png 768w"></em></figure><p></p><p><em>Set up and run a 20 step simulation with the chosen rules, rule domains defined by the image mask, and an initial condition array made of all zeros:</em></p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/picturesetup.gif" alt="" width="671" height="366"></figure><h2>Global boundary conditions of Coexisting CA simulations</h2><p>By default, CoexistingCellularAutomata assumes periodic boundary conditions on the simulation space, as in this trajectory of rule 10 and rule 90, where the leftmost cells of the array interact with the rightmost cells:</p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.29.51.png" alt="" width="251" height="212" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.29.51-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.29.51-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.29.51-md.png 768w"></figure><p>As a convenience to the end user, CoexistingCellularAutomata also supports specifying global boundary conditions using the <em>"GlobalMaskFunction"</em> and <em>"GlobalMaskValueFunction"</em> options. As their names suggest, these options are designed to receive function arguments. These should be functions of the state array at any given time, though they can also be made to ignore the state array input. </p><p>The <em>"GlobalMaskFunction"</em> option defines the boundary of the simulation by returning a binary mask where 1s represent cells that can be affected by the chosen CA rules, and 0s represent cells that cannot. The specified function may also return a 0, signalling that no special global boundary conditions should be added. The <em>"GlobalMaskValueFunction"</em> defines the values inside the boundary region, and can return a constant cell state value, or an array of valid cell states. When these functions return arrays, the arrays must have dimensions as the state array. </p><p>To add constant zero boundary conditions on the left and right ends of the state arrays in the previous simulation, only minimal changes to the code are needed. By adding </p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.30.42.png" alt="" width="492" height="42" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.30.42-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.30.42-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.30.42-md.png 768w"></figure><p>and </p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.31.08.png" alt="" width="283" height="31" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.31.08-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.31.08-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.31.08-md.png 768w"></figure><p>to the CoexistingCellularAutomata function call, we restrict the rule domains to all cells other than those near the border, and set the excluded border cells to be equal to 0 throughout the simulation:</p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.31.40.png" alt="" width="250" height="214" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.31.40-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.31.40-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.31.40-md.png 768w"></figure><p>Because <em>"GlobalMaskFunction"</em> and <em>"GlobalMaskValueFunction"</em> expect functions, and these functions are computed for every step of a Coexisting CA simulation, it's also quite easy to set dynamic boundary conditions. If instead, we had specified the options</p><figure class="post__image"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.32.30.png" alt="" width="508" height="34" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.32.30-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.32.30-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.32.30-md.png 768w"></figure><p>and </p><figure class="post__image"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.32.50.png" alt="" width="446" height="33" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.32.50-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.32.50-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.32.50-md.png 768w"></figure><p>we would get random dynamic boundary conditions on the boundaries of the simulation space:</p><figure class="post__image align-center"><img loading="lazy" src="https://phileasdg.github.io/media/posts/53/Screenshot-2026-01-17-at-12.33.11.png" alt="" width="250" height="207" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.33.11-xs.png 300w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.33.11-sm.png 480w, https://phileasdg.github.io/media/posts/53/responsive/Screenshot-2026-01-17-at-12.33.11-md.png 768w"></figure><h2>Closing thoughts</h2><p>There are many directions this work could go. It's easy to imagine how the setups we've explored here could become the basis form a kind of toy model of artificial life in which the organisms are wandering cellular automata whose spatial domain boundary conditions themselves are subject to environmental and competitive pressures. </p><p>Another direction might be to modify the setups explored in this essay to allow multiple CAs to occupy the same spatial domains, and compete for dominance over these overlapping regions. This would require careful planning, as there are many possibilities for how such overlapping claims could be handled, and all will inevitably come with their own advantages and tradeoffs.</p><p>What would you do next? If you find this work interesting, and you'd like to discuss it, please feel free to reach out. I'm excited to continue exploring this topic and to see what can come of it.</p></div><footer><p class="post__last-updated">This article was updated on January 17, 2026</p><div class="post__tags-share"><ul class="post__tag"><li><a href="https://phileasdg.github.io/tags/art/">Art</a></li><li><a href="https://phileasdg.github.io/tags/cellular-automata/">Cellular Automata</a></li><li><a href="https://phileasdg.github.io/tags/complex-systems/">Complex Systems</a></li><li><a href="https://phileasdg.github.io/tags/modelling/">Modelling</a></li><li><a href="https://phileasdg.github.io/tags/programming/">Programming</a></li><li><a href="https://phileasdg.github.io/tags/wolfram-language/">Wolfram Language</a></li></ul><aside class="post__share"></aside></div><nav class="post__nav"><div class="post__nav__prev"><a class="post__nav__link" href="https://phileasdg.github.io/mapping-global-land-cover-with-european-space-agency-data/" rel="prev">Previous Post<h3 class="h6">Mapping Global Land Cover with European Space Agency Data</h3></a></div></nav></footer></div></article></div><div class="post__related"><div class="wrapper"><h2 class="h5">Related posts</h2><div class="l-grid l-grid--4"><article class="c-card"><a href="https://phileasdg.github.io/mapping-global-land-cover-with-european-space-agency-data/" class="c-card__image"><img src="https://phileasdg.github.io/media/posts/52/banner.png" srcset="https://phileasdg.github.io/media/posts/52/responsive/banner-xs.png 300w, https://phileasdg.github.io/media/posts/52/responsive/banner-sm.png 480w, https://phileasdg.github.io/media/posts/52/responsive/banner-md.png 768w, https://phileasdg.github.io/media/posts/52/responsive/banner-lg.png 1200w" sizes="(min-width: 56.25em) 100vw, (min-width: 37.5em) 50vw, 100vw" loading="lazy" height="1228" width="1959" alt=""></a><div class="c-card__wrapper"><header class="c-card__header"><div class="c-card__tag"><a href="https://phileasdg.github.io/tags/geography-and-gis/">Geography &amp; GIS</a></div><h3 class="c-card__title"><a href="https://phileasdg.github.io/mapping-global-land-cover-with-european-space-agency-data/" class="invert">Mapping Global Land Cover with European Space Agency Data</a></h3></header><footer class="c-card__meta"><time datetime="2026-01-10T11:01">January 10, 2026</time></footer></div></article><article class="c-card"><a href="https://phileasdg.github.io/delphai-structured-communication-with-llms-in-a-simulated-delphi-process/" class="c-card__image"><img src="https://phileasdg.github.io/media/posts/45/Banner-image-Community-Post-LLM-Delphi-Method.png" srcset="https://phileasdg.github.io/media/posts/45/responsive/Banner-image-Community-Post-LLM-Delphi-Method-xs.png 300w, https://phileasdg.github.io/media/posts/45/responsive/Banner-image-Community-Post-LLM-Delphi-Method-sm.png 480w, https://phileasdg.github.io/media/posts/45/responsive/Banner-image-Community-Post-LLM-Delphi-Method-md.png 768w, https://phileasdg.github.io/media/posts/45/responsive/Banner-image-Community-Post-LLM-Delphi-Method-lg.png 1200w" sizes="(min-width: 56.25em) 100vw, (min-width: 37.5em) 50vw, 100vw" loading="lazy" height="747" width="1598" alt=""></a><div class="c-card__wrapper"><header class="c-card__header"><div class="c-card__tag"><a href="https://phileasdg.github.io/tags/ai/">AI</a></div><h3 class="c-card__title"><a href="https://phileasdg.github.io/delphai-structured-communication-with-llms-in-a-simulated-delphi-process/" class="invert">DelphAI: Structured Communication with LLMs in a Simulated Delphi Process</a></h3></header><footer class="c-card__meta"><time datetime="2025-08-15T22:17">August 15, 2025</time></footer></div></article><article class="c-card"><a href="https://phileasdg.github.io/creative-generative-design-with-mathematical-marbling/" class="c-card__image"><img src="https://phileasdg.github.io/media/posts/41/Mathematical-Marbling-Banner.png" srcset="https://phileasdg.github.io/media/posts/41/responsive/Mathematical-Marbling-Banner-xs.png 300w, https://phileasdg.github.io/media/posts/41/responsive/Mathematical-Marbling-Banner-sm.png 480w, https://phileasdg.github.io/media/posts/41/responsive/Mathematical-Marbling-Banner-md.png 768w, https://phileasdg.github.io/media/posts/41/responsive/Mathematical-Marbling-Banner-lg.png 1200w" sizes="(min-width: 56.25em) 100vw, (min-width: 37.5em) 50vw, 100vw" loading="lazy" height="2394" width="4000" alt=""></a><div class="c-card__wrapper"><header class="c-card__header"><div class="c-card__tag"><a href="https://phileasdg.github.io/tags/art/">Art</a></div><h3 class="c-card__title"><a href="https://phileasdg.github.io/creative-generative-design-with-mathematical-marbling/" class="invert">Creative Generative Design with Mathematical Marbling</a></h3></header><footer class="c-card__meta"><time datetime="2024-10-24T15:15">October 24, 2024</time></footer></div></article></div></div></div></main><footer class="footer"><div class="footer__social"><a href="https://www.instagram.com/phileasdg/" aria-label="Instagram" class="instagram"><svg><use xlink:href="https://phileasdg.github.io/assets/svg/svg-map.svg#instagram"/></svg> </a><a href="https://www.linkedin.com/in/phileas/" aria-label="LinkedIn" class="linkedin"><svg><use xlink:href="https://phileasdg.github.io/assets/svg/svg-map.svg#linkedin"/></svg> </a><a href="https://www.youtube.com/@phileasdg" aria-label="Youtube" class="youtube"><svg><use xlink:href="https://phileasdg.github.io/assets/svg/svg-map.svg#youtube"/></svg></a></div><div class="footer__copyright">Phileas Dazeley-Gaist</div></footer><script>window.publiiThemeMenuConfig = {    
      mobileMenuMode: 'sidebar',
      animationSpeed: 300,
      submenuWidth: 'auto',
      doubleClickTime: 500,
      mobileMenuExpandableSubmenus: true, 
      relatedContainerForOverlayMenuSelector: '.navbar',
   };</script><script defer="defer" src="https://phileasdg.github.io/assets/js/scripts.min.js?v=66112a161d5939d966ce2b20c13988d9"></script><script>var images = document.querySelectorAll('img[loading]');

      for (var i = 0; i < images.length; i++) {
         if (images[i].complete) {
               images[i].classList.add('is-loaded');
         } else {
               images[i].addEventListener('load', function () {
                  this.classList.add('is-loaded');
               }, false);
         }
      }</script></body></html>